class RadixHeap {
public:
    RadixHeap() : size_(0), last_(0) {
        buckets_min_.fill(std::numeric_limits<unsigned_key_type>::max());
    }

    void insert(long long node, long long distance) {
        const unsigned_key_type x = encode(distance);
        assert(last_ <= x);
        size_++;
        size_t bucket_index = find_bucket(x, last_);
        buckets_[bucket_index].emplace_back(x, node);
        buckets_min_[bucket_index] = std::min(buckets_min_[bucket_index], x);
    }

    long long findMin() {
        pull();
        return buckets_[0].back().second;
    }

    void deleteMin() {
        pull();
        buckets_[0].pop_back();
        size_--;
    }

    bool empty() const {
        return size_ == 0;
    }

private:
    using key_type = long long;
    using unsigned_key_type = unsigned long long;
  
    size_t size_;
    unsigned_key_type last_;
    static constexpr size_t num_buckets = std::numeric_limits<unsigned_key_type>::digits + 1;

    std::array<std::vector<std::pair<unsigned_key_type, key_type>>, num_buckets> buckets_;
    std::array<unsigned_key_type, num_buckets> buckets_min_;

    unsigned_key_type encode(key_type x) const {
        return static_cast<unsigned_key_type>(x) ^ (unsigned_key_type(1) << (std::numeric_limits<unsigned_key_type>::digits - 1));
    }

    size_t find_bucket(unsigned_key_type x, unsigned_key_type last) const {
        if(x == last) {
            return 0;
        } else {
            return 64 - __builtin_clzll(x ^ last);
        }
    }

    void pull() {
        assert(size_ > 0);
        if (!buckets_[0].empty()) return;

        size_t i;
        for (i = 1; buckets_[i].empty(); i++);
        last_ = buckets_min_[i];

        for (const auto& [distance, node] : buckets_[i]) {
            size_t new_bucket_index = find_bucket(distance, last_);
            buckets_[new_bucket_index].emplace_back(distance, node);
            buckets_min_[new_bucket_index] = std::min(buckets_min_[new_bucket_index], distance);
        }
        buckets_[i].clear();
        buckets_min_[i] = std::numeric_limits<unsigned_key_type>::max();
    }
};
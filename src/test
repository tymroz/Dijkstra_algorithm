std::vector<long long> Graph::dial(long long source, long long max_cost) {
    std::vector<long long> distances(num_vertices_, std::numeric_limits<long long>::max());
    distances[source] = 0;

    std::vector<std::vector<bool>> buckets(max_cost + 1, std::vector<bool>(num_vertices_, false));
    buckets[source] = true;
    long long currentBucket = 0;

    long long visitedCount = 0;
    while (visitedCount < num_vertices_) {
        while (!buckets[currentBucket].any()) {
            currentBucket = (currentBucket + 1) % (max_cost + 1);
        }

        for (long long u = 0; u < num_vertices_; ++u) {
            if (buckets[currentBucket][u]) {
                buckets[currentBucket][u] = false;
                visitedCount++;

                for (const Edge& edge : adjacency_list_[u]) {
                    long long v = edge.to;
                    long long weight = edge.cost;

                    if (distances[u] + weight < distances[v]) {
                        long long previousBucket = distances[v] % (max_cost + 1);
                        if (previousBucket != currentBucket) {
                            buckets[previousBucket][v] = false;
                        }
                        distances[v] = distances[u] + weight;
                        buckets[distances[v] % (max_cost + 1)][v] = true;
                    }
                }
            }
        }
        currentBucket = (currentBucket + 1) % (max_cost + 1);
    }
    return distances;
}